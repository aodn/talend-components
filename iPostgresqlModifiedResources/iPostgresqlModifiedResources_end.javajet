<%@ jet 
	imports="
		org.talend.core.model.process.INode 
		org.talend.core.model.process.ElementParameterParser 
		org.talend.core.model.metadata.IMetadataTable 
		org.talend.core.model.metadata.IMetadataColumn 
		org.talend.core.model.process.IConnection
		org.talend.core.model.process.IConnectionCategory
		org.talend.designer.codegen.config.CodeGeneratorArgument
		org.talend.core.model.metadata.types.JavaTypesManager
		org.talend.core.model.metadata.types.JavaType
		java.util.List 
    	java.util.Map		
	" 
%>
<% 
    CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
    INode node = (INode)codeGenArgument.getArgument();
    String cid = node.getUniqueName();	
%>

					// update file as 'harvested' for specified harvest type
					
				    try {
				    	// Open connection
						conn_<%=cid%> = java.sql.DriverManager.getConnection(url_<%=cid%>,userName_<%=cid%>,password_<%=cid%>);
						conn_<%=cid%>.setAutoCommit(false);
						
						// Determine if an existing harvest record for this file exists
						
						java.sql.Statement stmt_<%=cid%> = conn_<%=cid%>
								.createStatement();
	
						String fileHarvestCountQuery_<%=cid%> = "select count(1) from file_harvest "
								+ " WHERE harvest_type = '" + harvestType_<%=cid%> + "' "
								+ "   AND file_id = " + Long.toString(id_<%=cid%>);
								
						java.sql.ResultSet rs_<%=cid%> = stmt_<%=cid%>.executeQuery(fileHarvestCountQuery_<%=cid%>);
						
						// If a record exists, update it otherwise create one
						
						if (rs_<%=cid%>.next() && rs_<%=cid%>.getInt(1) > 0) {
							// Update the record to record the new last modified date that has been processed
							String update_<%=cid%> = "update file_harvest "
									+ " set last_moddate_harvested = ? WHERE harvest_type = ? AND file_id = ?";
							java.sql.PreparedStatement pstmtUpdate_<%=cid%> = conn_<%=cid%>
									.prepareStatement(update_<%=cid%>);
									
							pstmtUpdate_<%=cid%>.setTimestamp(1, new java.sql.Timestamp(lastModified_<%=cid%>.getTime()));
							pstmtUpdate_<%=cid%>.setString(2, harvestType_<%=cid%>);
							pstmtUpdate_<%=cid%>.setLong(3, id_<%=cid%>);
							
							pstmtUpdate_<%=cid%>.executeUpdate();
						} else {
							// Insert a record with for the file recording the last modified date harvested
							String insert_<%=cid%> = "insert into file_harvest "
									+ " (harvest_type, file_id, last_moddate_harvested) VALUES (?,?,?)";
							java.sql.PreparedStatement pstmtInsert_<%=cid%> = conn_<%=cid%>
									.prepareStatement(insert_<%=cid%>);
									
							pstmtInsert_<%=cid%>.setString(1, harvestType_<%=cid%>);
							pstmtInsert_<%=cid%>.setLong(2, id_<%=cid%>);
							pstmtInsert_<%=cid%>.setTimestamp(3, new java.sql.Timestamp(lastModified_<%=cid%>.getTime()));
							
							pstmtInsert_<%=cid%>.executeUpdate();
						}					
													
						// file has been successfully processed so commit changes
						conn_<%=cid%>.commit();
						
				    } finally {
				        if (conn_<%=cid%> != null) {
				            conn_<%=cid%>.rollback();
				            conn_<%=cid%>.close();
				            conn_<%=cid%> = null;
				        }
				    }

				} catch (Exception e) {
					// Log error and continue wih next resource
					logger_<%=cid%>.error("Exception while processing " + resourceUrl_<%=cid%>, e);
					// TODO: allow this behaviour to be turned off i.e. provide Die on error option
					// may also be good to process all url's that can be processed and then fail if 
					// there were any errors so still get a notification
					// or may be able to use nagios error appender
				}
							
			}
					
		} finally {
			// ensure input stream is always closed
			if (in_<%=cid%> != null) {
				in_<%=cid%>.close();
				in_<%=cid%> = null;
			}
		}
	} finally {
		// ensure temporary file is always deleted
		if (tempFile_<%=cid%> != null) {
			tempFile_<%=cid%>.delete(); 
		}
	}	
	
	globalMap.put("<%=cid %>_NB_RESOURCES", nb_resources_<%=cid %>);
		