<%@ jet 
imports="
    org.talend.core.model.process.INode 
    org.talend.core.model.metadata.IMetadataTable
    org.talend.core.model.metadata.IMetadataColumn
    org.talend.core.model.process.IConnection
    org.talend.core.model.process.IConnectionCategory
    org.talend.core.model.process.ElementParameterParser
    org.talend.designer.codegen.config.CodeGeneratorArgument
    org.talend.core.model.metadata.types.JavaTypesManager
    org.talend.core.model.metadata.types.JavaType
    java.util.List
    java.util.Map
    
"
%>

<%
CodeGeneratorArgument codeGenArgument = (CodeGeneratorArgument) argument;
INode node = (INode)codeGenArgument.getArgument();
String cid = node.getUniqueName();
String colAgg = ElementParameterParser.getValue(node,"__COL__");
String colAggType = "String"; // initial value
String operation = ElementParameterParser.getValue(node,"__OPERATION__");
boolean noColSelected = ElementParameterParser.getValue(node, "__NO_COL_SELECTED__").equals("true");

IMetadataColumn geometryColumn = null;
List<IMetadataTable> metadatas = node.getMetadataList();
if ((metadatas != null) && (metadatas.size() > 0)) {
    IMetadataTable metadata = metadatas.get(0);
    if (metadata != null) {
        List<IMetadataColumn> columns = metadata.getListColumns();
        for (int j = 0; j < columns.size(); j++) {
            IMetadataColumn column = columns.get(j);
            // Look for the geometry column to be used by the aggregation
            String typeToGenerate = JavaTypesManager.getTypeToGenerate(column.getTalendType(), column.isNullable());
            if(typeToGenerate.equals("Geometry")) {
                geometryColumn = column;
                break;
            }
        }
    }
}

if (geometryColumn == null){
    return "error(\"Cannot find a geometry column\");";
}
String colGeo = geometryColumn.getLabel();

%>

// <%= operation %>
class OperationStruct<%=cid %> {

<%
        if (operation.equals("makeLine")) {
%>

    com.vividsolutions.jts.linearref.LinearGeometryBuilder <%=colGeo %>;
    org.opengis.referencing.crs.CoordinateReferenceSystem inputCRS;
<%
        } else if (operation.equals("makeTrajectory")) {
%>
    private com.vividsolutions.jts.geom.GeometryFactory factory = new com.vividsolutions.jts.geom.GeometryFactory();
    private com.vividsolutions.jts.linearref.LinearGeometryBuilder builder = new com.vividsolutions.jts.linearref.LinearGeometryBuilder(factory);
    private org.opengis.referencing.crs.CoordinateReferenceSystem inputCRS;
    
    public void setInputCRS(org.opengis.referencing.crs.CoordinateReferenceSystem inputCRS) {
        this.inputCRS = inputCRS;
    }
    
    public void add(Geometry point) {
        com.vividsolutions.jts.geom.Coordinate lastCoord = builder.getLastCoordinate();

        com.vividsolutions.jts.geom.Point jtsPoint = (com.vividsolutions.jts.geom.Point) point._getInternalGeometry();
        com.vividsolutions.jts.geom.Coordinate coord = jtsPoint.getCoordinate();
        
        if (crossesAntiMeridian(lastCoord, coord)) {
            splitAtAntiMeridian(lastCoord, coord);
        }
        
        builder.add(coord);
    }
    
    public Geometry getTrajectory() {
        Geometry result = new Geometry(builder.getGeometry());
        result.setCRS(inputCRS);
        return result;
    }
    
    private boolean crossesAntiMeridian(com.vividsolutions.jts.geom.Coordinate lastCoord, com.vividsolutions.jts.geom.Coordinate coord) {
        if (lastCoord == null) return false;
        // assume crosses anti-meridian if distance between longitudes is > 180
        return Math.abs(coord.x - lastCoord.x) > 180;
    }
    
    private void splitAtAntiMeridian(com.vividsolutions.jts.geom.Coordinate lastCoord, com.vividsolutions.jts.geom.Coordinate coord) {
        com.vividsolutions.jts.geom.Coordinate endPoint = getIntersectionPoint(lastCoord, coord);
        com.vividsolutions.jts.geom.Coordinate startPoint = getIntersectionPoint(coord, lastCoord);
        
        builder.add(endPoint);
        builder.endLine();
        builder.add(startPoint);
    }
    
    private com.vividsolutions.jts.geom.Coordinate getIntersectionPoint(com.vividsolutions.jts.geom.Coordinate lastCoord, com.vividsolutions.jts.geom.Coordinate coord) {
        double longitude;
        double latitude;

        if (lastCoord.x > 0) {
            longitude = 180;
        } else {
            longitude = -179.999999999999;
        }
        
        // map coord longitude to longitude domain extended past the anti-meridian 
        double extendedLongitude = coord.x > 0 ? coord.x - 360 : coord.x + 360;

        // determine latitude at which line between two coords crosses the anti-meridian 
        latitude = ((longitude - lastCoord.x) * (coord.y - lastCoord.y)/(extendedLongitude - lastCoord.x)) + lastCoord.y;
        
        return new com.vividsolutions.jts.geom.Coordinate(longitude, latitude);
    }    
<%
        } else {
%>

    Geometry <%=colGeo %>;

<%
        }
%>

<%
List<? extends IConnection> incomingConnections = node.getIncomingConnections();
if (incomingConnections != null && !incomingConnections.isEmpty()) {
    for (IConnection conn : incomingConnections) {
        if (conn.getLineStyle().hasConnectionCategory(IConnectionCategory.DATA)) {
            IMetadataTable inMetadata = conn.getMetadataTable();
            for (IMetadataColumn column: inMetadata.getListColumns()) {
                if (column.getLabel().equals(colAgg)){   // Add aggregate column
                                                         // TODO : Could add a number of aggregated features
                    // Get column data type
                    JavaType javaType = JavaTypesManager.getJavaTypeFromId(column.getTalendType());
                    
                    if (javaType == JavaTypesManager.BOOLEAN) {
                        colAggType = "Boolean";
                    } else if (javaType == JavaTypesManager.BYTE) {
                        colAggType = "Byte";
                    } else if (javaType == JavaTypesManager.BYTE_ARRAY) {
                        colAggType = "byte[]";
                    } else if (javaType == JavaTypesManager.CHARACTER) {
                        colAggType = "Character";
                    } else if (javaType == JavaTypesManager.DATE) {
                        colAggType = "java.util.Date";
                    } else if (javaType == JavaTypesManager.DOUBLE) {
                        colAggType = "Double";
                    } else if (javaType == JavaTypesManager.FLOAT) {
                        colAggType = "Float";
                    } else if (javaType == JavaTypesManager.INTEGER) {
                        colAggType = "Integer";
                    } else if (javaType == JavaTypesManager.LONG) {
                        colAggType = "Long";
                    } else if (javaType == JavaTypesManager.SHORT) {
                        colAggType = "Short";
                    } else if (javaType == JavaTypesManager.STRING) {
                        colAggType = "String";
                    } else if (javaType == JavaTypesManager.OBJECT) {
                        colAggType = "Object";
                    } else if (javaType == JavaTypesManager.getJavaTypeFromId("id_Geometry")) {
                        colAggType = "Geometry";
                    }
                    break;
                }
            }
        }
    }
}
%>
}

java.util.Map<<%=colAggType %>, OperationStruct<%=cid %>> hash_<%=colAgg %>_<%=cid %> =
    new java.util.HashMap<<%=colAggType %>, OperationStruct<%=cid %>>();

OperationStruct<%=cid %> operation_result_<%=cid %> = null;
